### 29 - Lock-based Concurrent Data Structures

介绍了一些基于锁的并发数据结构.

#### 1. 并发计数器
一种称作 **approximate counter** 的方法: 每个线程有自己的计数器 `local` 和一个全局计数器 `global`. 每个线程的 `local` 在达到一个阈值 $S$ 时执行 `global += local`. 这比多个线程在一个锁上争抢的性能表现好上许多, $S$ 越大, 性能表现越好, 但是 `global` 的准确性也下降, 这是一个 trade-off.

#### 2. 并发链表
普通的实现即给每一个链表设置一个锁. 还有一种方法, 就是 **hand-over-hand locking** (**lock coupling**), 即给每个节点设置一把锁, 在遍历链表时, 先获取下一个节点的锁, 再释放本节点的锁, 但这个方法的性能表现仍然可能不佳. 一种设想是每隔 $n$ 个节点设置一把锁, 这可能改善性能表现.

> **TIP** 如果某种并行算法的 overhead 过多, 可能还不如不并行. 可以尝试多种实现, 毕竟 benchmark 不会骗人.

> **TIP** 在控制流复杂的时候, 例如存在提前返回的时候, 尤其小心锁的释放, 最好的避免方法就是把锁所覆盖的范围最小化.

#### 3. 并发队列
一把大锁保平安的做法对于队列来说不太行, 更合理的做法是在头和尾各设置一把锁, 并且巧妙地在头部设置一个 dummy node, 使得入列和出列操作分离.

#### 4. 并发哈希表
其实就是把一些并发链表组织起来.

> **TIP** 不要提前优化.